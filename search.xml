<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法的效率]]></title>
    <url>%2F2019%2F08%2F18%2Falgorithm%2F</url>
    <content type="text"><![CDATA[算法效率的度量事后统计方法​ 准备好测试程序和数据，利用计时器计数程序运行时间​ 缺陷： 1.费时费力 实现做好测试程序，花费大量时间，如果算法不符合要求，之前投入的大量的时间和精力都将浪费； 2.不同测试环境得出的结果差距很大 在一台高性能的计算机上用一个效率比较低的算法，我们得到的结果可能差强人意，但是在性能较差的计算机上，那效果就极差； 因此，我们需要一种事先在理论上计算算法效率的方法。 事前分析估算方法​ 进行理论分析时，主要考虑算法的时间复杂度和算法的空间复杂度。但是现代计算机的内存空间一般不存在不够用的情况，因此我们主要是需要考虑算法的时间复杂度。 算法效率的影响因素1.算法采用的策略 ​ 这是影响效率最根本的因素。采取的策略不同，算法也就不同。以下面两个算法为例，大家可以感受以下算法对于时间效率的影响。 ​ 题目：要求依次输出1~100的阶乘(可以用double存储近似结果) 算法一: 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int n=100; double ans; for(int i=1;i&lt;=n;i++) &#123; ans=1; for(int j=1;j&lt;=n;j++) &#123; ans= ans*j; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125; 算法二： 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int n=100; double ans; for(int i=1;i&lt;=n;i++) &#123; ans= ans*i; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; ​ 以上两种算法的优劣十分的明显，在PC上编译运行两种算法，我们甚至不用计时就可以明显感觉到第二种算法所花费的时间要短。当n更大时1，两者的运行时间差距将会更大。 1. 当n较大时，此算法将不再适用。因为数值过大导致double数值溢出，如需验证，则可以使用数组来存储结果。 &#8617; 2.问题的数据规模 ​ 前文两段代码中的n就是各自算法的数据规模，决定算法中主要操作的执行次数。 ​ 相同的算法，在不同的数据规模下的效率也是不同的。例如一个高级的排序算法在数据规模很大时，效率甩开插入排序、冒泡排序等几条街不止；但是当数据规模较小时，在效率上反而是略不如这些算法。 3.编译产生的代码质量 ​ 编译是将我们用高级语言写的代码转化为机器能识别的二进制代码。代码质量的影响因素很多，其中编译过程也会一定的影响代码质量，这主要是因为编译器采取了一些优化机制。当然编译过程不是影响代码质量的关键因素，代码质量的高低还是取决于程序员的。 4.机器执行指令的速度 ​ 这个就主要是由机器的性能决定，对结果的影响也很大。但是对于开发者而言，需要的是尽可能去优化算法，而不是一味的让用户去更换更先进的计算机。 算法的时间复杂度​ 算法的时间复杂度是指当问题的数据规模以某种单位从1增加到n时，解决这个问题所需的时间也以某种单位有1增加到t(n)。 以一段具体的代码为例： 12345int i, sum = 0, n = 100; //执行了1次for (i = 1; i &lt;=n; i++) //执行了n+1次&#123; sum+=i; //执行了n次&#125; ​ 以上代码执行了的时间复杂度为$t(n)=2*n+2$。 ​ 分析以上代码，我们可以发现int i, sum = 0, n = 100;的执行次数并不随输入规模的改变而改变；for (i = 1; i &lt;=n; i++)与sum+=i;的执行次数与输入规模有关。这种方式假设每条命令执行所需时间相同，只需计算出指令的执行次数就可以估计出程序的时间效率。 算法的渐进时间复杂度​ 算法的渐进时间复杂度g(n)是指不包括t(n)的低阶项和首项系数的函数，亦即考察输入值大小趋近无穷时的情况。一般情况下，我们衡量时间效率所说的时间复杂度其实是指渐进时间复杂度。下文提到的时间复杂度若无特别说明也是指渐进时间复杂度。 ​ 比如：一个算法的时间复杂度$t(n)=100n^2+100n+log_2n+10000$，其渐进时间复杂度为$O(n^2)$。 ​ 时间复杂度是衡量一个量级上的差距，这个量级上的差距表现在当n突破到一个点的时候，时间复杂度低的算法就一定要比时间复杂度高的算法快，而且n越大，这个优势越明显。而我们研究算法就是要处理大规模的数据，因为数据比较小的话，时间总是够用的。 ​ 复杂度高的算法可能它会有前面常数小的优势，所以在我们数据规模比较小的时候，它是有意义的，但是这是细节上的优化，但整体上我们还是要追求复杂度低的算法 时间复杂度的表示​ 时间复杂度常用大O符号表示，代表其渐进上界。还可以使用Θ表示紧确界，Ω代表渐进下界。 ​ O(大O符号）：上界 ​ 定义：若存在两个正的常数 c 和 $n_0 $, 对于任意 $n≥n_0$ , 都有 $T( n)≤cf( n)$ ,则称$T( n) = O( f( n) )$(或称算法在 $O( f( n))$中)。​ 大 O 符号用来描述增长率的上限,表示 T( n)的增长最多像 f( n)增长的那样快,也就是说, 当输入规模为 n时, 算法 消耗时间的最大值,这个上限的阶越低, 结果就越有价值。 ​ Ω（大Ω符号）：下界​ 定义：若存在两个正的常数 c和 $n_0$ ,对于任意$n≥ n_0$ , 都有 $T( n)≥cg( n)$ ,则称$T( n) = Ω( g( n) )$(或称算法在 $Ω( g( n) )$中)。​ 大 Ω符号用来描述增长率的下限, 也就是说, 当输入规模为 n 时,算法消耗时间的最小值。与大 O 符号对称, 这个 下限的阶越高,结果就越有价值。 ​ Θ(theta) ：紧确界​ 定义：若存在 3 个正的常数 $c_1 ,c_2 和 n_0 $,对于任意 $n≥ n_0$ , 都有$ c_1f(n)≥ T(n)≥ c_2f(n)$ , 则称$ T( n) = Θ( f(n))$。​ Θ符号意味着 T( n)与 f( n)同阶, 用来表示算法的精确阶。 常见的时间复杂度模型O(n!) > O(2^n) > O(n^2) >O(nlogn) >O(n) >O(logn) > O(1) 1.常量阶O(1) 2.对数阶O(logn) 3.线性阶O(n) 4.线性对数阶O(nlogn) 5.平方阶O($n^2$) 6.立方阶O($n^3$) 7.指数阶O($2^n$)和阶乘阶O($n!$) 不能忽视的情况 需要特别注意，取量级大的一部分的前提一定是我们这个算法它所处理的这两部分所对应的规模n是一样的 举例：将字符串按字母顺序排列，再将数组中的字符串按字典序排序 O(n*nlogn + nlogn)=O(n^2logn) (错)]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客那些事儿]]></title>
    <url>%2F2019%2F08%2F10%2Fpersonal-blog%2F</url>
    <content type="text"><![CDATA[​ 此博客长期更新 一、搭建博客踩的坑1.我的学习对象​ LixT大佬的博客搭建教程在我所看过的所有教程中堪称是最 最 最 0基础 的。我的个人博客基本是按照LixT的教程实现的。但是在过程中还是遇到了一些麻烦，还有一些思路上的不同，所以这篇博文就相当于是对LixT教程的一个小小的补充。 2.本地测试无法访问 ​ 在搭建静态博客的过程中，为了便于查看博客内容或者页面的效果，我们常常进行本地测试。hexo s后在本地浏览器输入localhost即可查看博客内容，但是也可能会遇到上图中的情况。 ​ 输入hexo s默认去使用本地4000端口，但是本地4000端口被其他服务占用，导致不能访问。此时我们可以更换一个本地部署的端口： 1hexo s -p 5000 ​ 这个命令将本地部署到5000端口，浏览器URL则填入localhost:5000。 ​ 当然，更换为4001端口之类的也是可以的，浏览器输入的URL要与设定的端口一致。 二、博客维护踩的坑1.&lt;! -- more --&gt;失效​ 对于较长的博文，博文在主页展示时如果全部展示不仅不美观，而且十分的浪费空间。在Markdown的语法中，我们可以在博客中使用&lt;! -- more --&gt;,之前的内容可以在主页显示，之后的内容进入博客后才能看到。但是经常遇到的问题确实博文主页的确不是显示全文，但是显示的内容却也不是按照我们的想法来进行分割的。对想要在主页展示部分图片的用户造成了极大的困扰。 ​ 在主题配置文件中找到上图内容，配置文件中excerpt_description默认设置为true，这导致主页始终只能显示md文件的front-matter（可理解为 序言）部分的 description内容。将excerpt_description设置为false后，&lt;! -- more --&gt;就能有效果了。 ​ 如果不想进入博文后直接从&lt;! -- more --&gt;后的内容开始阅读， 可以将scroll_to_more设置为false，此项根据个人需要决定。 2.网页中图片无法显示​ 这个问题是很多人都遇到过的问题，在本地 编辑，甚至在一些Markdown编辑器中图片都能正常显示，但是网页中却显示不出来。 ​ 博客编辑时，图片的组织有两种方式，一种是直接存放在source\images文件夹之内，但是并不太推荐此种方式，因为含有多篇博文时，所有博文的图片都放在图一个文件夹中，不利于图片的管理；第二种方式可以形象的理解为“一个萝卜一个坑”，每篇博文，都对应有一个同名文件夹，将本篇博文的图片放在该文件夹中即可。 ​ 第二种方式的具体操作如下： 1.修改主题配置文件​ 将主题配置文件中的post_asset_folder设置为true，这样每次用命令hexo new post ‘名字’时，会直接在source_post中生成一个md文件和一个放图片的同名文件夹。 2.安装hexo-asset-image插件1npm install hexo-asset-image --save 3.使用![图片描述](文件夹名/图片名)引用图片​ 此处需注意，引用路径时使用/而不是Windows下常用的\,因为知识HTML的URL，必须使用/，在有些编辑器中（比如我用的Typora），不论使用哪一种都可以显示图片，但是使用\时的HTML文件路径是有错的，最终导致网页中图片无法显示。 附：关于[% asset_img slug title %] ​ 我查看许多人关于这个描述，这是hexo的一个标签插件，可以解决![alt](path)引用的图片无法在主页显示的问题。但是经过我的测试，我发现![alt](path)引用的图片可以在主页和文章中完美显示。并且不知道是否因为版本问题，在md文件中使用[% asset_img slug title %]反而无法在网页中正常显示。使用hexo g之后查看本地public\2019\08\10\personal-blog\index.html (该博文的路径)，查看图片引用处代码，发现使用[% asset_img slug title %]生成的HTML源码的图片路径有误。 ​ ![alt](path)生成的正常的路径源码： ​ [% asset_img slug title %]生成的错误的路径源码： 注：以上内容中[% asset_img slug title %]的[]应该换为{}，在hexo生成的HTML文件中无法显示，故以此代替。 3.部署到GitHub的网页与本地部署的网页不一致最常见的一种情况就是背景图片不见了，查看GitHub上的仓库中的存放位置，发现所部署的背景图片存在，但是访问时就是无法显示，只需在本地博客文件夹目录下打开cmd或者git，输入: 123hexo cleanhexo ghexo d 重复几次，耐心等待网页刷新，背景图片便能显示。 此外，我还遇到了代码块的复制按钮和打赏按钮变形的情况，使用上述操作后也恢复了正常。 4.代码块颜色显示代码块分为长代码块和短代码块。短代码块使用”`”来包裹代码，我尝试过使用如下代码来使得短代码块显示其他颜色： 1&lt;font color=red&gt;`代码块`&lt;/font&gt; 但遗憾的是并非没有达到预期效果，之后去查看也下大佬的网页源码，得到了启发，获得了以下解决方法： 1&lt;code style=&quot;color:red&quot;&gt;代码块&lt;/code&gt; 5.数学符号渲染失败我们在md文件中输入$$来实现数学符号，却发现网页中仍然存在$符号，数学公式也没有渲染成功，查阅资料后发现都是hexo自带数学公式渲染插件惹的祸，由于某些符号与hexo的标签符号冲突，导致不能成功渲染。只需更换对应插件就可以了。 在本地博客文件夹目录下打开cmd或者git，输入: 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 更换插件后，新插件仍然由符号冲突，我们需要手动更改。修改博客根目录下的node_modules\hexo-renderer-kramed\lib\rules\inline.js的内容: 12345//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>博客维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git上传本地项目到github]]></title>
    <url>%2F2019%2F08%2F09%2Fgit%2F</url>
    <content type="text"><![CDATA[1.在本地创建Git可管理的版本库在本地进入待上传项目的文件夹，右键单击，选择Git Bash here； 输入 git init 创建版本库； 创建成功后文件夹中会出现一个.git的文件，该文件用来跟踪和管理版本库，是隐藏文件，需设置为显示隐藏项目才能显示。 2.将项目提交到仓库git工作流程如下图： 本地的项目文件位于工作区，初始状态是未加入git仓库的。使用 git add .1 或者 git add [文件名或文件夹名] 2将工作区文件加入暂存区；3待确定该次版本修改完成后，使用 git commit 4可将暂存区文件提交到本地git仓库（版本库）。 1. 输入 git add . 将工作区所有文件及文件夹放入暂存区； &#8617; 2. 输入 git add [文件名或文件夹名] 将工作区部分文件及文件夹放入暂存区； &#8617; 3:输入 git status可查看处于暂存区的文件（夹）目录，默认为绿色显示；4: 常使用 git commit -m &#39;版本描述&#39;。 3.在Github上创建一个仓库，并获取该仓库的URL在Github上新建一个仓库(Repository)，获取仓库的URL,即下图红框所标注的内容。 4.将Github上的远程仓库与本地仓库关联1git remote add origin https://github.com/austinmarsray/test.git origin之后填写对应仓库的URL。 5.将本地仓库内容推送到Github远程仓库1git push -u origin master 第一次上传时远程仓库为空，需使用-u,之后推送可直接使用 1git push origin master 当创建仓库时选择了创建readme.md时，此步骤会报错。 12git pull --rebase origin mastergit push -u origin master 按以上步骤即可正常推送内容。 6.Github仓库中显示项目内容]]></content>
      <categories>
        <category>Git的基本使用</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
