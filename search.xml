<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++深入学习 之 再读C++ Primer Plus]]></title>
    <url>%2F2019%2F09%2F13%2FCPlusPlus-study%2F</url>
    <content type="text"><![CDATA[1.C++语言概述C++与C的关系密切，两者不仅同出于贝尔实验室，并且C++本身就是C的一个超集。早期的C++并没有直接到目标语言（机器语言）的编译器，而是使用一种cfront的编译器将C++翻译为C源码，再通过标准C编译器翻译为目标语言。 再加上后期加入的泛型编程的思想，C++集OOP、面向过程的方法、泛型编程于一体。OOP赋予了C++将问题所涉及概念联系起来的能力，C语言赋予了C++紧密联系内存的能力，而泛型编程思想大大提高了C++程序员的编程效率，促进了C++的广泛传播。 2.C++程序创建过程3.C++编译过程4.]]></content>
      <categories>
        <category>C++深入学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶之路-数据类型]]></title>
    <url>%2F2019%2F09%2F02%2Fjava-learning-datatype%2F</url>
    <content type="text"><![CDATA[1.Java的数据类型分类1.1.基本类型Java的基本数据类型共8种：6种数字类型（4种整数型、2种浮点型） + 1种字符型 + 1种布尔型 byte int short long float double char boolean 1.2.引用类型引用类型有class(类)、interface(接口)、array(数组)以及null(空类型)四类。 2.Java数据类型详解2.1.基本类型2.1.1.byte byte 数据类型是8位(1字节)1、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50 2.1.2.short short 数据类型是 16 位(2字节)、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000 2.1.3.int int 数据类型是32位(4字节)、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000 2.1.4.long long 数据类型是 64 位(8字节)、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L 2.1.5.char char类型是一个单一的 16 位 (2字节)Unicode 字符； 最小值是 \u0000（即为0）； 最大值是 \uffff（即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’; 2.1.6.float float 数据类型是单精度、32位(4字节)的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值； 例子：float f1 = 234.5f 2.1.7.double double 数据类型是双精度、64 位(8字节)的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值； 默认值是 0.0d； 例子：double d1 = 123.4 2.1.8.boolean boolean占用的字节数在《Java虚拟机规范》中并没有一个准确的说法，目前最广泛被接受的就是It depends on Java virtual machine. 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true2 2.1.9.总结我们可以使用以下代码来了解各种数据类型的取值范围与默认值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class PrimitiveTypeTest &#123; static byte BYTE; static short SHORT; static int INT; static long LONG; static float FLOAT; static double DOUBLE; static char CHAR; static boolean BOOLEAN; public static void main(String[] args) &#123; //boolean System.out.println("默认值：" + BOOLEAN); System.out.println(); // byte System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE); System.out.println("包装类：java.lang.Byte"); System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE); System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE); System.out.println("默认值：" + BYTE); System.out.println(); // short System.out.println("基本类型：short 二进制位数：" + Short.SIZE); System.out.println("包装类：java.lang.Short"); System.out.println("最小值：Short.MIN_VALUE=" + Short.MIN_VALUE); System.out.println("最大值：Short.MAX_VALUE=" + Short.MAX_VALUE); System.out.println("默认值：" + SHORT); System.out.println(); // int System.out.println("基本类型：int 二进制位数：" + Integer.SIZE); System.out.println("包装类：java.lang.Integer"); System.out.println("最小值：Integer.MIN_VALUE=" + Integer.MIN_VALUE); System.out.println("最大值：Integer.MAX_VALUE=" + Integer.MAX_VALUE); System.out.println("默认值：" + INT); System.out.println(); // long System.out.println("基本类型：long 二进制位数：" + Long.SIZE); System.out.println("包装类：java.lang.Long"); System.out.println("最小值：Long.MIN_VALUE=" + Long.MIN_VALUE); System.out.println("最大值：Long.MAX_VALUE=" + Long.MAX_VALUE); System.out.println("默认值：" + LONG); System.out.println(); // float System.out.println("基本类型：float 二进制位数：" + Float.SIZE); System.out.println("包装类：java.lang.Float"); System.out.println("最小值：Float.MIN_VALUE=" + Float.MIN_VALUE); System.out.println("最大值：Float.MAX_VALUE=" + Float.MAX_VALUE); System.out.println("默认值：" + FLOAT); System.out.println(); // double System.out.println("基本类型：double 二进制位数：" + Double.SIZE); System.out.println("包装类：java.lang.Double"); System.out.println("最小值：Double.MIN_VALUE=" + Double.MIN_VALUE); System.out.println("最大值：Double.MAX_VALUE=" + Double.MAX_VALUE); System.out.println("默认值：" + DOUBLE); System.out.println(); // char System.out.println("基本类型：char 二进制位数：" + Character.SIZE); System.out.println("包装类：java.lang.Character"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println("最小值：Character.MIN_VALUE=" + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println("最大值：Character.MAX_VALUE=" + (int) Character.MAX_VALUE); System.out.println("默认值：" + CHAR); &#125; &#125; 运行结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243默认值：false基本类型：byte 二进制位数：8包装类：java.lang.Byte最小值：Byte.MIN_VALUE=-128最大值：Byte.MAX_VALUE=127默认值：0基本类型：short 二进制位数：16包装类：java.lang.Short最小值：Short.MIN_VALUE=-32768最大值：Short.MAX_VALUE=32767默认值：0基本类型：int 二进制位数：32包装类：java.lang.Integer最小值：Integer.MIN_VALUE=-2147483648最大值：Integer.MAX_VALUE=2147483647默认值：0基本类型：long 二进制位数：64包装类：java.lang.Long最小值：Long.MIN_VALUE=-9223372036854775808最大值：Long.MAX_VALUE=9223372036854775807默认值：0基本类型：float 二进制位数：32包装类：java.lang.Float最小值：Float.MIN_VALUE=1.4E-45最大值：Float.MAX_VALUE=3.4028235E38默认值：0.0基本类型：double 二进制位数：64包装类：java.lang.Double最小值：Double.MIN_VALUE=4.9E-324最大值：Double.MAX_VALUE=1.7976931348623157E308默认值：0.0基本类型：char 二进制位数：16包装类：java.lang.Character最小值：Character.MIN_VALUE=0最大值：Character.MAX_VALUE=65535默认值： 2.2.引用类型2.2.1.类(class type)Java是一门面向对象的编程语言，除了基本数据类型以外，Java程序的最小单元就是类。 类是对某一类事物的描述，是抽象的、概念上的定义；对象是实际存在的该类事物的个体，因而也称实例(Instance)。类和对象就如同概念和实物之间的关系一样，类就好比是一个模板，而对象就是该模板下的一个实例。 类中可以包括数据成员和方法。 123456789101112131415public class MyDate&#123;//----------------数据成员 int year; int month; int day;//----------------方法 void printdate()&#123; //略 &#125; void reset()&#123; //略 &#125;//----------------&#125; 类的实例化方式： 12MyDate today; //此时today==nulltoday = new MyDate(); //调用构造函数，此时才在内存中分配空间 2.2.2.接口(interface type)Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为(功能)。 1234public interface Print&#123; boolean print_color(int x); boolean print_format(int x);&#125; 接口中只有抽象方法，只有方法的声明、特征，而没有具体的实现方法。接口内的成员皆为static,final,public，他们可以成为任何类或接口的类型。 接口不能实例化，但是能被类实现。 12345678910public class MyDate implements Print &#123; public boolean print_color(int x) &#123; //具体实现方法 &#125; public boolean print_format(int x) &#123; //具体实现方法 &#125;&#125; 2.2.3.数组(array type)12345double[] mylist; //声明数组变量此时mylist==nullmylist=new double[10];//分配内存空间MyDate[] list;list=new MyDate[10]; //无论数组中元素位基本类型还是引用类型，数组都是引用类型 2.2.4.空类型(null type)空类型其实不能算作一种引用数据类型，类、接口、数组的对象被声明但还没有被构造(分配内存空间)时的默认值都是null。 2.2.5.总结引用类型使用一种类似C语言中指针的方法，直接指向对象所在的内存空间，并可以直接操作对象行为。 引用类型的具体使用并不仅仅上述内容，之后将继续更新相关内容。点我跳转 3.基本类型与引用类型的区别基本类型中变量名指向一个具体值，在声明一个基本类型变量时，就为该变量分配了内存空间。 引用变量中变量名指向对象的内存地址，在声明一个引用类型变量时，并不分配内存空间，而是赋值为一个null(空类型)，直到实例化对象（或类实现接口）时才会分配内存空间，并赋值一个地址值。 引用类型在赋值和传递参数时与基本类型差别较大。 12int a=10;int b=a; 以上代码中两个int类型的变量a,b在内存中位于不同的地址，是相互独立的。 123String a="Hello World";String b=a;String c="Hello World"; String类是Java中自带的引用类型，其中变量a,b实质上只是一个变量，两者的内存地址相同。而变量则是与a变量相互独立的。 其实，从上述两个例子中我们可以得知：引用类型对象相互赋值时实质上是就是C++中的引用，变量名只是一种别名；只有new(部分类可以直接使用 ‘=’ 构造对象)的才是独立的对象。 此外，在函数间传递参数时，引用类型也是地址传递而非值传递。 4.Java常量【等待更新……】 5.Java数据类型转换【等待更新……】 5.1.自动转换5.2.强制转换 1. 计算机中内存最小存储单位为位(bit),每一位中只有0和1两种状态；计算机中表示信息的最小单位是字节(byte),计算机中，一个内存地址代表一个字节（byte）的存储空间。两者存在关系：1 byte=8 bit. &#8617; 2. 本博客中基本数据类型部分大量引用了菜鸟教程的内容，仅对少量阐述不清的内容进行了补充。 &#8617;]]></content>
      <categories>
        <category>Java进阶之路</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的效率]]></title>
    <url>%2F2019%2F08%2F18%2Falgorithm%2F</url>
    <content type="text"><![CDATA[算法效率的度量事后统计方法​ 准备好测试程序和数据，利用计时器计数程序运行时间​ 缺陷： 1.费时费力 实现做好测试程序，花费大量时间，如果算法不符合要求，之前投入的大量的时间和精力都将浪费； 2.不同测试环境得出的结果差距很大 在一台高性能的计算机上用一个效率比较低的算法，我们得到的结果可能差强人意，但是在性能较差的计算机上，那效果就极差； 因此，我们需要一种事先在理论上计算算法效率的方法。 事前分析估算方法​ 进行理论分析时，主要考虑算法的时间复杂度和算法的空间复杂度。但是现代计算机的内存空间一般不存在不够用的情况，因此我们主要是需要考虑算法的时间复杂度。 算法效率的影响因素1.算法采用的策略 ​ 这是影响效率最根本的因素。采取的策略不同，算法也就不同。以下面两个算法为例，大家可以感受以下算法对于时间效率的影响。 ​ 题目：要求依次输出1~100的阶乘(可以用double存储近似结果) 算法一: 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int n=100; double ans; for(int i=1;i&lt;=n;i++) &#123; ans=1; for(int j=1;j&lt;=n;j++) &#123; ans= ans*j; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125; 算法二： 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int n=100; double ans; for(int i=1;i&lt;=n;i++) &#123; ans= ans*i; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; ​ 以上两种算法的优劣十分的明显，在PC上编译运行两种算法，我们甚至不用计时就可以明显感觉到第二种算法所花费的时间要短。当n更大时1，两者的运行时间差距将会更大。 1. 当n较大时，此算法将不再适用。因为数值过大导致double数值溢出，如需验证，则可以使用数组来存储结果。 &#8617; 2.问题的数据规模 ​ 前文两段代码中的n就是各自算法的数据规模，决定算法中主要操作的执行次数。 ​ 相同的算法，在不同的数据规模下的效率也是不同的。例如一个高级的排序算法在数据规模很大时，效率甩开插入排序、冒泡排序等几条街不止；但是当数据规模较小时，在效率上反而是略不如这些算法。 3.编译产生的代码质量 ​ 编译是将我们用高级语言写的代码转化为机器能识别的二进制代码。代码质量的影响因素很多，其中编译过程也会一定的影响代码质量，这主要是因为编译器采取了一些优化机制。当然编译过程不是影响代码质量的关键因素，代码质量的高低还是取决于程序员的。 4.机器执行指令的速度 ​ 这个就主要是由机器的性能决定，对结果的影响也很大。但是对于开发者而言，需要的是尽可能去优化算法，而不是一味的让用户去更换更先进的计算机。 算法的时间复杂度​ 算法的时间复杂度是指当问题的数据规模以某种单位从1增加到n时，解决这个问题所需的时间也以某种单位有1增加到t(n)。 以一段具体的代码为例： 12345int i, sum = 0, n = 100; //执行了1次for (i = 1; i &lt;=n; i++) //执行了n+1次&#123; sum+=i; //执行了n次&#125; ​ 以上代码执行了的时间复杂度为$t(n)=2*n+2$。 ​ 分析以上代码，我们可以发现int i, sum = 0, n = 100;的执行次数并不随输入规模的改变而改变；for (i = 1; i &lt;=n; i++)与sum+=i;的执行次数与输入规模有关。这种方式假设每条命令执行所需时间相同，只需计算出指令的执行次数就可以估计出程序的时间效率。 算法的渐进时间复杂度​ 算法的渐进时间复杂度g(n)是指不包括t(n)的低阶项和首项系数的函数，亦即考察输入值大小趋近无穷时的情况。一般情况下，我们衡量时间效率所说的时间复杂度其实是指渐进时间复杂度。下文提到的时间复杂度若无特别说明也是指渐进时间复杂度。 ​ 比如：一个算法的时间复杂度$t(n)=100n^2+100n+log_2n+10000$，其渐进时间复杂度为$O(n^2)$。 ​ 时间复杂度是衡量一个量级上的差距，这个量级上的差距表现在当n突破到一个点的时候，时间复杂度低的算法就一定要比时间复杂度高的算法快，而且n越大，这个优势越明显。而我们研究算法就是要处理大规模的数据，因为数据比较小的话，时间总是够用的。 ​ 复杂度高的算法可能它会有前面常数小的优势，所以在我们数据规模比较小的时候，它是有意义的，但是这是细节上的优化，但整体上我们还是要追求复杂度低的算法 时间复杂度的表示​ 时间复杂度常用大O符号表示，代表其渐进上界。还可以使用Θ表示紧确界，Ω代表渐进下界。 ​ O(大O符号）：上界 ​ 定义：若存在两个正的常数 c 和 $n_0 $, 对于任意 $n≥n_0$ , 都有 $T( n)≤cf( n)$ ,则称$T( n) = O( f( n) )$(或称算法在 $O( f( n))$中)。​ 大 O 符号用来描述增长率的上限,表示 T( n)的增长最多像 f( n)增长的那样快,也就是说, 当输入规模为 n时, 算法 消耗时间的最大值,这个上限的阶越低, 结果就越有价值。 ​ Ω（大Ω符号）：下界​ 定义：若存在两个正的常数 c和 $n_0$ ,对于任意$n≥ n_0$ , 都有 $T( n)≥cg( n)$ ,则称$T( n) = Ω( g( n) )$(或称算法在 $Ω( g( n) )$中)。​ 大 Ω符号用来描述增长率的下限, 也就是说, 当输入规模为 n 时,算法消耗时间的最小值。与大 O 符号对称, 这个 下限的阶越高,结果就越有价值。 ​ Θ(theta) ：紧确界​ 定义：若存在 3 个正的常数 $c_1 ,c_2 和 n_0 $,对于任意 $n≥ n_0$ , 都有$ c_1f(n)≥ T(n)≥ c_2f(n)$ , 则称$ T( n) = Θ( f(n))$。​ Θ符号意味着 T( n)与 f( n)同阶, 用来表示算法的精确阶。 常见的时间复杂度模型O(n!) > O(2^n) > O(n^2) >O(nlogn) >O(n) >O(logn) > O(1) 1.常量阶O(1) 2.对数阶O(logn) 3.线性阶O(n) 4.线性对数阶O(nlogn) 5.平方阶O($n^2$) 6.立方阶O($n^3$) 7.指数阶O($2^n$)和阶乘阶O($n!$) 不能忽视的情况 需要特别注意，取量级大的一部分的前提一定是我们这个算法它所处理的这两部分所对应的规模n是一样的 举例：将字符串按字母顺序排列，再将数组中的字符串按字典序排序 O(n*nlogn + nlogn)=O(n^2logn) (错)]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客那些事儿]]></title>
    <url>%2F2019%2F08%2F10%2Fpersonal-blog%2F</url>
    <content type="text"><![CDATA[​ 此博客长期更新 1.搭建博客踩的坑1.1.我的学习对象​ LixT大佬的博客搭建教程在我所看过的所有教程中堪称是最 最 最 0基础 的。我的个人博客基本是按照LixT的教程实现的。但是在过程中还是遇到了一些麻烦，还有一些思路上的不同，所以这篇博文就相当于是对LixT教程的一个小小的补充。 1.2.本地测试无法访问 ​ 在搭建静态博客的过程中，为了便于查看博客内容或者页面的效果，我们常常进行本地测试。hexo s后在本地浏览器输入localhost即可查看博客内容，但是也可能会遇到上图中的情况。 ​ 输入hexo s默认去使用本地4000端口，但是本地4000端口被其他服务占用，导致不能访问。此时我们可以更换一个本地部署的端口： 1hexo s -p 5000 ​ 这个命令将本地部署到5000端口，浏览器URL则填入localhost:5000。 ​ 当然，更换为4001端口之类的也是可以的，浏览器输入的URL要与设定的端口一致。 1.3.添加标签页和分类页在source\tags\index.md 中的配置文件中添加type: tags，即可创建标签页。在source\categories\index.md中配置文件添加type: categories即可创建分类页。 且两者无需手动添加标签或分类，只要在每篇博文的开头设置tags和categories，则标签或分类将自动加入标签页和分类页。 1.4.更改标签云样式在themes\next\layout\page.swig文件中做以下改动：原配置： 12345678910111213141516171819&#123;% if page.type === 'tags' %&#125;&lt;div class="tag-cloud"&gt; &lt;div class="tag-cloud-title"&gt; &#123;% set visibleTags = 0 %&#125; &#123;% for tag in site.tags %&#125; &#123;% if tag.length %&#125; &#123;% set visibleTags += 1 %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;&#123; _p('counter.tag_cloud', visibleTags) &#125;&#125; &lt;/div&gt; &lt;div class="tag-cloud-tags"&gt; &#123;% if not theme.tagcloud %&#125; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: '#ccc', end_color: '#111'&#125;) &#125;&#125; &#123;% else %&#125; &#123;&#123; tagcloud(&#123;min_font: theme.tagcloud.min, max_font: theme.tagcloud.max, amount: theme.tagcloud.amount, color: true, start_color: theme.tagcloud.start, end_color: theme.tagcloud.end&#125;) &#125;&#125; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt; 更改为： 12345678910111213141516171819 &#123;% if page.type === 'tags' %&#125; &lt;div class="tag-cloud"&gt; &lt;div class="tag-cloud-title"&gt; &#123;% set visibleTags = 0 %&#125; &#123;% for tag in site.tags %&#125; &#123;% if tag.length %&#125; &#123;% set visibleTags += 1 %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;&#123; _p('counter.tag_cloud', visibleTags) &#125;&#125; &lt;/div&gt; &lt;div class="tag-cloud-tags"&gt; &#123;% if not theme.tagcloud %&#125; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: '#ccc', end_color: '#111'&#125;) &#125;&#125; &#123;% else %&#125; &#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125;&#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt; 标签的颜色和大小均可改变样式，只需要含color和font的项就可，具体改动可根据自己的想法来实现。上述改动的颜色为紫色，效果图如下： ​ 1.5.显示Mist主题副标题Mist主题中默认是隐藏副标题的，在themes\next\source\css\_schemes\Mist\_logo.styl下将.site-subtitle { display: none; }修改为.site-subtitle { display: yes; }即可展示副标题。副标题内容的设置在博客配置文件中设置。 1.6.去除Mist主题侧边框阴影在Mist主题中，默认进入文章后会弹出一个侧边框用于显示文章章节、当前阅读条目等。但是侧边框边框的阴影效果实在时太难看了，提供给大家一个去除侧边框阴影的办法。在themes\next\source\css\_common\components\sidebar\sidebar.styl中将box-shadow: inset 0 2px 2px black;这一行内容注释掉即可。 1.7.侧边栏添加背景图如果你需要在你的侧边栏加上你想要的图案，那么在themes\next\source\css\_custom\custom.styl中添加以下内容： 123.sidebar &#123; background: url(/images/sidebar.jpg);&#125; 背景图的路径可以根据自己的需要进行修改，甚至可以改为所需图片的网络URL。 如果时想将侧边栏这只为纯色，将background改为color，并设置为需要的颜色的十六进制表示。 2.博客维护踩的坑2.1.&lt;! -- more --&gt;失效​ 对于较长的博文，博文在主页展示时如果全部展示不仅不美观，而且十分的浪费空间。在Markdown的语法中，我们可以在博客中使用&lt;! -- more --&gt;,之前的内容可以在主页显示，之后的内容进入博客后才能看到。但是经常遇到的问题确实博文主页的确不是显示全文，但是显示的内容却也不是按照我们的想法来进行分割的。对想要在主页展示部分图片的用户造成了极大的困扰。 ​ 在主题配置文件中找到上图内容，配置文件中excerpt_description默认设置为true，这导致主页始终只能显示md文件的front-matter（可理解为 序言）部分的 description内容。将excerpt_description设置为false后，&lt;! -- more --&gt;就能有效果了。 ​ 如果不想进入博文后直接从&lt;! -- more --&gt;后的内容开始阅读， 可以将scroll_to_more设置为false，此项根据个人需要决定。 2.2.网页中图片无法显示​ 这个问题是很多人都遇到过的问题，在本地 编辑，甚至在一些Markdown编辑器中图片都能正常显示，但是网页中却显示不出来。 ​ 博客编辑时，图片的组织有两种方式，一种是直接存放在source\images文件夹之内，但是并不太推荐此种方式，因为含有多篇博文时，所有博文的图片都放在图一个文件夹中，不利于图片的管理；第二种方式可以形象的理解为“一个萝卜一个坑”，每篇博文，都对应有一个同名文件夹，将本篇博文的图片放在该文件夹中即可。 ​ 第二种方式的具体操作如下： 1.修改主题配置文件 ​ 将主题配置文件中的post_asset_folder设置为true，这样每次用命令hexo new post ‘名字’时，会直接在source_post中生成一个md文件和一个放图片的同名文件夹。 2.安装hexo-asset-image插件 1npm install hexo-asset-image --save 3.使用![图片描述](文件夹名/图片名)引用图片 ​ 此处需注意，引用路径时使用/而不是Windows下常用的\,因为知识HTML的URL，必须使用/，在有些编辑器中（比如我用的Typora），不论使用哪一种都可以显示图片，但是使用\时的HTML文件路径是有错的，最终导致网页中图片无法显示。 附： ​ 我查看许多人关于这个描述，这是hexo的一个标签插件，可以解决![alt](path)引用的图片无法在主页显示的问题。但是经过我的测试，我发现![alt](path)引用的图片可以在主页和文章中完美显示。并且不知道是否因为版本问题，在md文件中使用[% asset_img slug title %]反而无法在网页中正常显示。使用hexo g之后查看本地public\2019\08\10\personal-blog\index.html (该博文的路径)，查看图片引用处代码，发现使用[% asset_img slug title %]生成的HTML源码的图片路径有误。 ​ ![alt](path)生成的正常的路径源码： ​ [% asset_img slug title %]生成的错误的路径源码： 注：以上内容中[% asset_img slug title %]的[]应该换为{}，在hexo生成的HTML文件中无法显示，故以此代替。 2.3.部署到GitHub的网页与本地部署的网页不一致最常见的一种情况就是背景图片不见了，查看GitHub上的仓库中的存放位置，发现所部署的背景图片存在，但是访问时就是无法显示，只需在本地博客文件夹目录下打开cmd或者git，输入: 123hexo cleanhexo ghexo d 重复几次，耐心等待网页刷新，背景图片便能显示。 此外，我还遇到了代码块的复制按钮和打赏按钮变形的情况，使用上述操作后也恢复了正常。 2.4.代码块颜色显示代码块分为长代码块和短代码块。短代码块使用”`”来包裹代码，我尝试过使用如下代码来使得短代码块显示其他颜色： 1&lt;font color=red&gt;`代码块`&lt;/font&gt; 但遗憾的是并非没有达到预期效果，之后去查看也下大佬的网页源码，得到了启发，获得了以下解决方法： 1&lt;code style=&quot;color:red&quot;&gt;代码块&lt;/code&gt; 后续更新: 对于短代码块而言，可以在配置文件中修改默认设置，从而全局改变短代码块的字体颜色。在themes\next\source\css\_custom\custom.sty中添加如下代码： 12345//代码块配置code &#123; color: #ff0000; background: #fbf7f8;&#125; 2.5.数学符号渲染失败我们在md文件中输入$$来实现数学符号，却发现网页中仍然存在$符号，数学公式也没有渲染成功，查阅资料后发现都是hexo自带数学公式渲染插件惹的祸，由于某些符号与hexo的标签符号冲突，导致不能成功渲染。只需更换对应插件就可以了。 在本地博客文件夹目录下打开cmd或者git，输入: 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 更换插件后，新插件仍然由符号冲突，我们需要手动更改。修改博客根目录下的node_modules\hexo-renderer-kramed\lib\rules\inline.js的内容: 12345//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>博客维护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git上传本地项目到github]]></title>
    <url>%2F2019%2F08%2F09%2Fgit%2F</url>
    <content type="text"><![CDATA[1.在本地创建Git可管理的版本库在本地进入待上传项目的文件夹，右键单击，选择Git Bash here； 输入 git init 创建版本库； 创建成功后文件夹中会出现一个.git的文件，该文件用来跟踪和管理版本库，是隐藏文件，需设置为显示隐藏项目才能显示。 2.将项目提交到仓库git工作流程如下图： 本地的项目文件位于工作区，初始状态是未加入git仓库的。使用 git add .1 或者 git add [文件名或文件夹名] 2将工作区文件加入暂存区；3待确定该次版本修改完成后，使用 git commit 4可将暂存区文件提交到本地git仓库（版本库）。 1. 输入 git add . 将工作区所有文件及文件夹放入暂存区； &#8617; 2. 输入 git add [文件名或文件夹名] 将工作区部分文件及文件夹放入暂存区； &#8617; 3:输入 git status可查看处于暂存区的文件（夹）目录，默认为绿色显示；4: 常使用 git commit -m &#39;版本描述&#39;。 3.在Github上创建一个仓库，并获取该仓库的URL在Github上新建一个仓库(Repository)，获取仓库的URL,即下图红框所标注的内容。 4.将Github上的远程仓库与本地仓库关联1git remote add origin https://github.com/austinmarsray/test.git origin之后填写对应仓库的URL。 5.将本地仓库内容推送到Github远程仓库1git push -u origin master 第一次上传时远程仓库为空，需使用-u,之后推送可直接使用 1git push origin master 当创建仓库时选择了创建readme.md时，此步骤会报错。 12git pull --rebase origin mastergit push -u origin master 按以上步骤即可正常推送内容。 6.Github仓库中显示项目内容]]></content>
      <categories>
        <category>Git的基本使用</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
